
// Generated by Robert M. Lefkowitz <code@liberally.net> in 2024 using ChatGPT
// from files containing the following notices:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1987, 1993, 1994
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import Foundation

public enum argType: Int32 {
  case no_argument = 0
  case required_argument = 1
  case optional_argument = 2
}

public struct option {
  public let name: String
  public let has_arg: argType

  public init(_ n: String, _ h: argType) {
    self.name = n
    self.has_arg = h
  }
}

public class BSDGetopt_long {

  var optind = 0

  struct GLFlags: OptionSet {
    let rawValue: UInt8

    static let FLAG_PERMUTE = GLFlags(rawValue: 0x01)
    static let FLAG_ALLARGS = GLFlags(rawValue: 0x02)
    static let FLAG_LONGONLY = GLFlags(rawValue: 0x04)
  }

  //  let FLAG_PERMUTE = 0x01  /* permute non-options to the end of argv */
  //  let FLAG_ALLARGS = 0x02  /* treat non-options as args to option "-1" */
  //  let FLAG_LONGONLY = 0x04  /* operate as getopt_long_only */

  /* return values */
  let BADARG: String

  var opterr = true

  let INORDER = "\u{01}"

  var options: String
  var long_options: [option]
  var nargv: [String]

  var posixly_correct: Bool

  var optopt: Character = "?"
  var optarg: String = ""

  let NO_PREFIX = -1
  let D_PREFIX = 0
  let DD_PREFIX = 1
  let W_PREFIX = 2

  var nonopt_start = -1 // first non option argument (for permute)
  var nonopt_end = -1   // first option after non options (for permute)

  var dash_prefix = -1  // NO_PREFIX

  var place = ""

  public init(
    _ s: String, _ long_options: [option],
    _ args: [String] = Array(CommandLine.arguments.dropFirst())
  ) {
    self.options = s
    self.nargv = args
    self.long_options = long_options
    optind = 0

    BADARG = s.first == ":" ? ":" : "?"

    // Disable GNU extensions if POSIXLY_CORRECT is set or options string begins with a '+'.
    posixly_correct = getenv("POSIXLY_CORRECT") != nil
  }

  /// Compute the greatest common divisor of a and b.
  func gcd(_ aa: Int, _ bb: Int) -> Int {
    var a = aa
    var b = bb
    var c = a % b
    while c != 0 {
      a = b
      b = c
      c = a % b
    }
    return b
  }

  /**
   * Exchange the block from nonopt_start to nonopt_end with the block
   * from nonopt_end to opt_end (keeping the same order of arguments
   * in each block).
   */
  func permute_args(
    _ panonopt_start: Int, _ panonopt_end: Int, _ opt_end: Int,
    _ nargv: inout [String]
  ) {
    // compute lengths of blocks and number and size of cycles
    let nnonopts = panonopt_end - panonopt_start
    let nopts = opt_end - panonopt_end
    let ncycle = gcd(nnonopts, nopts)
    let cyclelen = (opt_end - panonopt_start) / ncycle

    for i in 0..<ncycle {
      let cstart = panonopt_end + i
      var pos = cstart
      for _ in 0..<cyclelen {
        if pos >= panonopt_end {
          pos -= nnonopts
        } else {
          pos += nopts
        }

        let swap = nargv[pos]
        nargv[pos] = nargv[cstart]
        nargv[cstart] = swap
      }
    }
  }

  /**
   * parse_long_options --
   *  Parse long options in argc/argv argument vector.
   * Returns -1 if short_too is set and the option does not match long_options.
   */
  func
    parse_long_options(_ short_too: Bool, _ flags: GLFlags) throws(CmdErr) -> (
      String, String
    )?
  {
    //  char *current_argv, *has_equal;

    var current_dash: String = ""

    //  size_t current_argv_len;
    //  int i, match, exact_match, second_partial_match;

    let cur_argv = place

    switch dash_prefix {
    case D_PREFIX:
      current_dash = "-"
    case DD_PREFIX:
      current_dash = "--"
    case W_PREFIX:
      current_dash = "-W "
    default:
      current_dash = ""
    }

    var match = -1
    var exact_match = false
    var second_partial_match = false

    optind += 1

    var current_key: String
    //    var current_val : String?

    let has_equal = cur_argv.firstIndex(of: "=")
    if let has_equal {
      // argument found (--option=arg)
      current_key = String(cur_argv.prefix(upTo: has_equal))
    } else {
      current_key = cur_argv
    }

    for (i, opt) in long_options.enumerated() {
      /* find matching long option */
      if !opt.name.hasPrefix(current_key) {
        continue
      }

      if opt.name.count == current_key.count {
        /* exact match */
        match = i
        exact_match = true
        break
      }

      // If this is a known short option, don't allow a partial match of a single character.
      if short_too && current_key.count == 1 {
        continue
      }

      if match == -1 { // first partial match
        match = i
      } else if flags.contains(.FLAG_LONGONLY)
        || long_options[i].has_arg != long_options[match].has_arg
      {
        second_partial_match = true
      }
    }
    if !exact_match && second_partial_match {
      // ambiguous abbreviation
      throw CmdErr(1, "option \(current_dash)\(current_key) is ambiguous")
    }

    if match != -1 { // option found
      if let has_equal, long_options[match].has_arg == .no_argument {
        // FIXME: do I need to set optopt (or pass it to CmdErr)
        throw CmdErr(
          1, "option \(current_dash)\(current_key) doesn't allow an argument")
      }
      if long_options[match].has_arg == .required_argument
        || long_options[match].has_arg == .optional_argument
      {
        if let has_equal {
          optarg = String(place.suffix(from: has_equal).dropFirst())
        } else if long_options[match].has_arg == .required_argument {
          // optional argument doesn't use next nargv
          optarg = nargv[optind]
          optind += 1
        }
      }
      if long_options[match].has_arg == .required_argument && optarg == "" {
        /*
         * Missing argument; leading ':' indicates no error
         * should be generated.
         */
        optind -= 1
        // FIXME: do I need to pass optopt to the err?
        throw CmdErr(1, "option \(current_dash)\(current_key) requires an argument")
      }
    } else { // unknown option
      if short_too {
        optind -= 1
        return nil
      }
      throw CmdErr(1, "unrecognized option \(current_dash)\(current_key)")
    }

    return (long_options[match].name, optarg)
  }

  // -=================================================================================================================

  /**
   * getopt_internal --
   *  Parse argc/argv argument vector.  Called by user level routines.
   */
  func getopt_internal(_ flagsx: GLFlags) throws(CmdErr) -> (String, String)? {

    var optchar: String = "?"
    var short_too = false

    var flags = flagsx
    if options.first == "-" {
      flags.formUnion(.FLAG_ALLARGS)
    } else if posixly_correct || options.first == "+" {
      flags.remove(.FLAG_PERMUTE)
    }
    if options.first == "+" || options.first == "-" {
      options.removeFirst()
    }

    while true {
      // start:
      if place.isEmpty { // update scanning pointer
        if optind >= nargv.count { // end of argument vector
          place = ""
          if nonopt_end != -1 {
            // do permutation, if we have to
            permute_args(nonopt_start, nonopt_end, optind, &nargv)
            optind -= nonopt_end - nonopt_start
          } else if nonopt_start != -1 {
            // If we skipped non-options, set optind to the first of them.
            optind = nonopt_start
          }
          nonopt_start = -1
          nonopt_end = -1
          return nil
        }

        place = nargv[optind]
        if place.first != "-" || place.count == 1 {
          place = "" /* found non-option */
          if flags.contains(.FLAG_ALLARGS) {
            // GNU extension: return non-option as argument to option 1
            optarg = nargv[optind]
            optind += 1
            return (INORDER, optarg)
          }
          if !flags.contains(.FLAG_PERMUTE) {
             // If no permutation wanted, stop parsing at first non-option.
            return nil
          }
          // do permutation
          if nonopt_start == -1 {
            nonopt_start = optind
          } else if nonopt_end != -1 {
            permute_args(nonopt_start, nonopt_end, optind, &nargv)
            nonopt_start = optind - (nonopt_end - nonopt_start)
            nonopt_end = -1
          }
          optind += 1
          // process next argument
          continue

        }

        if nonopt_start != -1 && nonopt_end == -1 {
          nonopt_end = optind
        }

        // If we have "-" do nothing, if "--" we are done.
        if place.count > 1 {
          place.removeFirst()
          if place == "-" {
            optind += 1
            place = ""

             // We found an option (--), so if we skipped non-options, we have to permute.
            if nonopt_end != -1 {
              permute_args(nonopt_start, nonopt_end, optind, &nargv)
              optind -= nonopt_end - nonopt_start
            }
            nonopt_start = -1
            nonopt_end = -1
            return nil
          }
        }
      }
      break
    }
    /*
     * Check long options if:
     *  1) we were passed some
     *  2) the arg is not just "-"
     *  3) either the arg starts with -- we are getopt_long_only()
     */
    if place != nargv[optind]
      && (place.first == "-" || flags.contains(.FLAG_LONGONLY))
    {
      short_too = false

      dash_prefix = D_PREFIX

      if place.first == "-" {
        place.removeFirst() /* --foo long option */
        if place.isEmpty {
          throw CmdErr(1, "malformed option")  //  BADARG  /* malformed option */
        }

        dash_prefix = DD_PREFIX

      } else if place.first != ":"
        && strchr(options, Int32(UnicodeScalar(place.first!.asciiValue!).value))
          != nil
      {
        short_too = true /* could be short option too */
      }

      if let k = try parse_long_options(short_too, flags) {
        place = ""
        return k
      }
    }

    let oc = place.removeFirst()
    var oli: Character?
    var oli2: Character?
    var oli3: Character?
    if let oo = options.firstIndex(of: oc) {
      let olix = options.suffix(from: oo)
      oli = olix.first
      oli2 = olix.dropFirst().first
      oli3 = olix.dropFirst(2).first
    }
    optchar = String(oc)

    if optchar == ":" || (optchar == "-" && !place.isEmpty) || oli == nil {
      /*
       * If the user specified "-" and  '-' isn't listed in
       * options, return -1 (non-option) as per POSIX.
       * Otherwise, it is an unknown option character (or ':').
       */
      if optchar == "-" && place.isEmpty {
        return nil
      }
      if place.isEmpty {
        optind += 1
      }
      throw CmdErr( 1, posixly_correct ? 
                    "illegal option -- \(optchar)"
                    : "invalid option -- \(optchar)")
    }
    if optchar == "W" && oli2 == ";" {
      // -W long-option
      if !place.isEmpty { // no space
        // NOTHING
      } else {
        optind += 1
        if optind >= nargv.count { // no arg
          place = ""
          throw CmdErr(1, "option requires an argument -- \(optchar)")
        } else { // white space
          place = nargv[optind]
        }
      }

      dash_prefix = W_PREFIX

      return try parse_long_options(false, flags)
    }
    if oli2 != ":" { // doesn't take argument
      if place.isEmpty {
        optind += 1
      }
    } else { // takes (optional) argument
      optarg = ""
      if !place.isEmpty { // no white space
        optarg = place
      } else if oli3 != ":" { // arg not optional
        optind += 1
        if optind >= nargv.count { // no arg
          place = ""

          throw CmdErr(1, "option requires an argument -- \(optchar)")
        } else {
          optarg = nargv[optind]
        }
      }
      place = ""
      optind += 1
    }
    // dump back option letter
    return (optchar, optarg)
  }

  /// Parse argc/argv argument vector.
  public func getopt_long() throws(CmdErr) -> (String, String)? {
    return try getopt_internal(GLFlags.FLAG_PERMUTE)
  }

  /// getopt_long_only -- Parse argc/argv argument vector.
  public func getopt_long_only() throws(CmdErr) -> (String, String)? {
    return try getopt_internal(GLFlags.FLAG_PERMUTE.union(.FLAG_LONGONLY))
  }

  public var remaining: [String] {
    return Array(nargv.dropFirst(optind))
  }
}

// ===================================================================

public class BSDGetopt {
  var optarg: String = ""  // argument associated with option

  var ostr: String
  var nargv: ArraySlice<String>
  var place = ""

  let PROGNAME = CommandLine.arguments[0]

  /// parse the command line options using the option definition string `ostr`.  Optionally, pass in the array of strings to be used as the argument array -- otherwise the default `CommandLine.arguments` will be used
  public init(
    _ ostr: String, args: ArraySlice<String> = CommandLine.arguments.dropFirst()
  ) {
    self.ostr = ostr
    self.nargv = args
  }

  /// return the arguments remaining after the options processing has completed
  public var remaining: [String] { Array(nargv) }

  /// consume the next argument (assuming it has been processed elsewhere)
  public func skip(_ n: Int = 1) {
    nargv = nargv.dropFirst(n)
  }

  /// Parse the next option -- returning the option character and the option argument (or nil if the next token is not an option)
  public func getopt() throws(CmdErr) -> (Character, String)? {
    var optopt: Character = "?"  // character checked for validity
    guard nargv.count > 0 else {
      return nil
    }

    if place.isEmpty {
      place = nargv.first!

      guard !place.isEmpty, place.removeFirst() == "-" else {
        // Argument is absent or is not an option
        place = ""
        return nil
      }

      //    nargv.removeFirst()  // consume this token
      if place == "-" {
        nargv.removeFirst()
        place = ""
        // "--" => end of options
        return nil
      }

      if place.isEmpty {
        // Solitary '-', treat as a '-' option if the program (eg su) is looking for it.
        if ostr.contains("-") {
          optopt = "-"
        } else {
          return nil
        }
      } else {
        optopt = place.removeFirst()
      }
    } else {
      optopt = place.removeFirst()
    }

    // See if option letter is one the caller wanted...
    if optopt == ":" || !ostr.contains(optopt) {
      if place.isEmpty {
        nargv.removeFirst()
      }
      //   place = nargv.count == 0 ? "" : nargv.removeFirst()
      // }
      if ostr.first != ":" {
        throw CmdErr(1, "\(PROGNAME): illegal option -- \(optopt)")
      }
    }

    // Does this option need an argument?
    if ostr.range(of: "\(optopt):") == nil {
      // don't need argument
      optarg = ""
      if place.isEmpty { nargv.removeFirst() }
    } else {
      // Option-argument is either the rest of this argument or the entire next argument.
      if !place.isEmpty {
        optarg = place
      } else if ostr.contains("\(optopt)::") {
        // GNU Extension, for optional arguments if the rest of the argument is empty, we return ""
        optarg = ""
      } else if nargv.count > 1 {
        nargv.removeFirst()
        optarg = nargv.first!
      } else {
        // option-argument absent
        if !nargv.isEmpty { nargv.removeFirst() }
        optarg = ""
        place = ""
        if ostr.first == ":" {
          return (":", "")
        }
        throw CmdErr(1, "\(PROGNAME): option requires an argument \(optopt)")
      }
      place = ""
      if !nargv.isEmpty { nargv.removeFirst() }
    }
    return (optopt, optarg)  // return option letter and argument
  }
}
